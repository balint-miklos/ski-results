<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ski Race Results ‚õ∑Ô∏è</title>
    <!-- D3.js library from a CDN -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Using a nice font from Google Fonts */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Style for the main race group header row */
        .group-header {
            background-color: #e5e7eb; /* A darker gray */
            font-weight: 700;
            color: #1f2937;
            cursor: pointer;
        }
        /* Style for the athlete sub-header row */
        .athlete-header {
            background-color: #f3f4f6; /* A light gray */
            font-weight: 600;
            /* No cursor pointer as it's not clickable */
        }
        .indicator {
            display: inline-block;
            width: 1.5em;
            text-align: center;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800 p-4 sm:p-8">

    <div class="max-w-7xl mx-auto">
        <header class="text-center mb-8">
            <h1 class="text-3xl sm:text-4xl font-bold text-gray-900">Ski Race Results Database</h1>
            <p class="text-md text-gray-600 mt-2">Race results grouped by event and athlete. Click race headers to expand or collapse.</p>
        </header>

        <!-- Filter input box -->
        <div class="mb-8 max-w-md mx-auto">
            <input type="text" id="filter-input" placeholder="Filter results..." class="w-full px-4 py-2 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500">
        </div>
        
        <!-- This empty table element is where D3 will render the data -->
        <div class="bg-white rounded-lg shadow-md overflow-x-auto">
            <table id="results-table" class="w-full text-sm text-left text-gray-500">
                <!-- D3 will generate the content here -->
            </table>
        </div>
    </div>

    <script>
        // URL to the CSV file. A relative path works if the CSV is in the same folder.
        const csvUrl = './ski-data.csv';

        // Use d3.csv to load and parse the data from the external file
        d3.csv(csvUrl, d => {
            // This function is applied to each row as it's loaded
            d.Rank = +d.Rank; // Convert Rank from string to number
            return d;
        }).then(function(originalData) {
            // This block of code runs ONLY after the data has been successfully loaded.

            const table = d3.select('#results-table');
            const filterInput = d3.select('#filter-input');
            
            // Define columns for the event data rows
            const eventDataColumns = originalData.columns.filter(d => !['RaceName', 'Name', 'Date'].includes(d));

            // Event listener for the filter input
            filterInput.on('input', function() {
                const filterValue = this.value.toLowerCase();
                
                if (filterValue) {
                    const filteredData = originalData.filter(row => {
                        const columnsToFilter = ['Name', 'Category', 'RaceName', 'Event', 'Rank', 'Date'];
                        
                        const substringMatch = columnsToFilter.some(column => 
                            String(row[column]).toLowerCase().includes(filterValue)
                        );

                        let specialMatch = false;
                        if ((filterValue === 'medal' || filterValue === 'medals') && (row.Rank >= 1 && row.Rank <= 3)) {
                            specialMatch = true;
                        } else if (filterValue === 'gold' && row.Rank === 1) {
                            specialMatch = true;
                        } else if (filterValue === 'silver' && row.Rank === 2) {
                            specialMatch = true;
                        } else if (filterValue === 'bronze' && row.Rank === 3) {
                            specialMatch = true;
                        }
                        
                        return substringMatch || specialMatch;
                    });
                    renderTable(filteredData, true);
                } else {
                    renderTable(originalData, false);
                }
            });

            // Main function to render the table with a given dataset
            function renderTable(data, isFiltering) {
                table.html('');

                // Helper function to get the start of the week (Sunday) in UTC
                function getStartOfWeekUTC(dateStr) {
                    const d = new Date(dateStr);
                    const day = d.getUTCDay(); // 0 = Sunday
                    const diff = d.getUTCDate() - day;
                    return new Date(Date.UTC(d.getUTCFullYear(), d.getUTCMonth(), diff));
                }

                // Determine the start of the most recent week from the current dataset
                const latestDateStr = d3.max(data, d => d.Date);
                let startOfMostRecentWeek = null;
                if (latestDateStr) {
                    startOfMostRecentWeek = getStartOfWeekUTC(latestDateStr + 'T00:00:00Z');
                }

                const thead = table.append('thead').attr('class', 'text-xs text-gray-700 uppercase bg-gray-50');
                const headerRow = thead.append('tr');
                headerRow.append('th').attr('class', 'px-6 py-3');
                headerRow.selectAll('th.data-header')
                    .data(eventDataColumns)
                    .join('th')
                    .attr('class', 'data-header px-6 py-3')
                    .attr('scope', 'col')
                    .text(d => d);

                const groupedByRace = d3.group(data, d => d.RaceName);
                const raceEntries = Array.from(groupedByRace.entries());

                // Sort races chronologically, most recent first
                raceEntries.sort(([raceNameA, resultsA], [raceNameB, resultsB]) => {
                    const maxDateA = d3.max(resultsA, d => d.Date);
                    const maxDateB = d3.max(resultsB, d => d.Date);
                    return new Date(maxDateB) - new Date(maxDateA);
                });

                raceEntries.forEach(([raceName, results]) => {
                    const tbody = table.append('tbody');
                    
                    let isInitiallyCollapsed = true;
                    if (isFiltering) {
                        isInitiallyCollapsed = false; // Always expand when filtering
                    } else if (startOfMostRecentWeek) {
                        const raceMaxDateStr = d3.max(results, d => d.Date);
                        const raceStartOfWeek = getStartOfWeekUTC(raceMaxDateStr + 'T00:00:00Z');
                        // Expand if the race's week is the same as the most recent week
                        if (raceStartOfWeek.getTime() === startOfMostRecentWeek.getTime()) {
                            isInitiallyCollapsed = false;
                        }
                    }

                    if (isInitiallyCollapsed) {
                        tbody.classed('collapsed', true);
                    }

                    // Create the results summary string
                    const ranks = results.map(r => r.Rank).sort((a, b) => a - b);
                    const summary = ranks.map(rank => {
                        if (rank === 1) return 'ü•á';
                        if (rank === 2) return 'ü•à';
                        if (rank === 3) return 'ü•â';
                        return rank;
                    }).join(' ');

                    // Create the date range string
                    const uniqueDates = [...new Set(results.map(r => r.Date))].sort();
                    let dateString = '';
                    if (uniqueDates.length > 0) {
                        const firstDate = new Date(uniqueDates[0] + 'T00:00:00Z');
                        const month = firstDate.toLocaleString('en-US', { month: 'short', timeZone: 'UTC' });
                        const year = firstDate.getUTCFullYear();
                        const firstDay = firstDate.getUTCDate();

                        if (uniqueDates.length > 1) {
                            const lastDate = new Date(uniqueDates[uniqueDates.length - 1] + 'T00:00:00Z');
                            const lastDay = lastDate.getUTCDate();
                            dateString = `${firstDay}-${lastDay} ${month} ${year}`;
                        } else {
                            dateString = `${firstDay} ${month} ${year}`;
                        }
                    }

                    const raceHeader = tbody.append('tr')
                        .attr('class', 'group-header')
                        .on('click', function() {
                            const isCollapsed = tbody.classed('collapsed');
                            tbody.classed('collapsed', !isCollapsed);
                            tbody.selectAll('tr:not(.group-header)')
                                 .style('display', isCollapsed ? 'table-row' : 'none');
                            d3.select(this).select('.indicator').text(isCollapsed ? '[-]' : '[+]');
                        });
                    
                    raceHeader.append('td')
                        .attr('colspan', eventDataColumns.length + 1)
                        .attr('class', 'px-6 py-3 text-lg')
                        .html(`<span class="indicator">${isInitiallyCollapsed ? '[+]' : '[-]'}</span>${raceName} (${dateString}, ${summary})`);
                    
                    const groupedByAthlete = d3.group(results, d => d.Name);
                    const sortedAthletes = Array.from(groupedByAthlete.entries()).sort((a, b) => a[0].localeCompare(b[0]));

                    sortedAthletes.forEach(([athleteName, athleteEvents]) => {
                        athleteEvents.sort((a, b) => a.Event.localeCompare(b.Event));

                        tbody.append('tr')
                            .attr('class', 'athlete-header')
                            .append('td')
                            .attr('colspan', eventDataColumns.length + 1)
                            .attr('class', 'px-6 py-2 font-medium text-gray-800 border-t')
                            .style('padding-left', '2rem')
                            .text(athleteName);

                        athleteEvents.forEach(event => {
                            const row = tbody.append('tr').attr('class', 'bg-white hover:bg-gray-50');
                            row.append('td').attr('class', 'border-t');
                            eventDataColumns.forEach(column => {
                                const cell = row.append('td')
                                    .attr('class', 'px-6 py-4 border-t');
                                
                                if (column === 'Rank') {
                                    let rankText = event[column];
                                    if (event[column] === 1) rankText = 'ü•á ' + rankText;
                                    else if (event[column] === 2) rankText = 'ü•à ' + rankText;
                                    else if (event[column] === 3) rankText = 'ü•â ' + rankText;
                                    cell.text(rankText);
                                } else {
                                    cell.text(event[column]);
                                }
                            });
                        });
                    });

                    if (isInitiallyCollapsed) {
                        tbody.selectAll('tr:not(.group-header)').style('display', 'none');
                    }
                });
            }

            // Initial render of the full table, not filtering
            renderTable(originalData, false);
        });

    </script>
</body>
</html>
